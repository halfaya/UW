{-# OPTIONS --cubical --safe #-}

module NattyCubical where

open import Cubical.Core.Everything using (_≡_; Level; Type; Σ; _,_; fst; snd; _≃_; ~_)

open import Cubical.Foundations.Prelude     using (refl; sym; _∙_; cong; transport; subst; funExt; transp; I; i0; i1)
open import Cubical.Foundations.Function    using (_∘_)
open import Cubical.Foundations.Univalence  using (ua)
open import Cubical.Foundations.Isomorphism using (iso; Iso; isoToPath; section; retract)

open import Data.Nat using (ℕ; zero; suc; _>_; s≤s; z≤n; _≤_; _+_)

----------------------

data Bin : Set where
  b0 : Bin         -- 0
  s1 : Bin → Bin   -- 2*n + 1
  s2 : Bin → Bin   -- 2*{n+1}

bsuc : Bin → Bin
bsuc b0     = s1 b0
bsuc (s1 n) = s2 n
bsuc (s2 n) = s1 (bsuc n)

----------------------

-- Equivalence between ℕ and Bin

doubleℕ : ℕ → ℕ
doubleℕ zero    = zero
doubleℕ (suc n) = suc (suc (doubleℕ n))

ℕ→Bin : ℕ → Bin
ℕ→Bin zero     = b0
ℕ→Bin (suc n) = bsuc (ℕ→Bin n)

Bin→ℕ : Bin → ℕ
Bin→ℕ b0     = zero
Bin→ℕ (s1 b) = suc (doubleℕ (Bin→ℕ b))
Bin→ℕ (s2 b) = doubleℕ (suc (Bin→ℕ b))

bsuc-suc : (b : Bin) → Bin→ℕ (bsuc b) ≡ suc (Bin→ℕ b)
bsuc-suc b0     = refl
bsuc-suc (s1 b) = refl
bsuc-suc (s2 b) = cong (suc ∘ doubleℕ) (bsuc-suc b)

ℕ→Bin→ℕ : (n : ℕ) → Bin→ℕ (ℕ→Bin n) ≡ n
ℕ→Bin→ℕ zero    = refl
ℕ→Bin→ℕ (suc n) = bsuc-suc (ℕ→Bin n) ∙ cong suc (ℕ→Bin→ℕ n)

doubleℕ-s1 : (n : ℕ) → bsuc (ℕ→Bin (doubleℕ n)) ≡ s1 (ℕ→Bin n)
doubleℕ-s1 zero    = refl
doubleℕ-s1 (suc n) = cong (bsuc ∘ bsuc) (doubleℕ-s1 n)

Bin→ℕ→Bin : (b : Bin) → ℕ→Bin (Bin→ℕ b) ≡ b
Bin→ℕ→Bin b0     = refl
Bin→ℕ→Bin (s1 b) = doubleℕ-s1 (Bin→ℕ b) ∙ cong s1 (Bin→ℕ→Bin b)
Bin→ℕ→Bin (s2 b) = cong bsuc (doubleℕ-s1 (Bin→ℕ b)) ∙ cong s2 (Bin→ℕ→Bin b)

isoℕBin : Iso ℕ Bin
isoℕBin = iso ℕ→Bin Bin→ℕ Bin→ℕ→Bin ℕ→Bin→ℕ

ℕ≡Bin : ℕ ≡ Bin
ℕ≡Bin = isoToPath isoℕBin

----------------------

-- doubleBin is a bit tricky to define directly.
doubleBin : Bin → Bin
doubleBin b0     = b0
doubleBin (s1 b) = s2 (doubleBin b) -- 2b+1 → 2(2b+1)   = 4b+2
doubleBin (s2 b) = s2 (s1 b)        -- 2b+2 → 2(2b+1+1) = 4b+4

-- No thought required to do it via transport.
doubleBin' : Bin → Bin
doubleBin' = transport ℕ≡Bin ∘ doubleℕ ∘ transport (sym ℕ≡Bin)

-- Surprisingly fast!
aaa : Bin
aaa = doubleBin' (s1 (s2 (s1 (s1 b0)))) -- 2 * 17

_ : aaa ≡ s2 (s2 (s1 (s1 (s1 b0)))) -- 34
_ = refl

-- But can we prove the two are equal? Here's an idea of the terms generated by effective transport.
-- Note that very naturally the transported terms are exactly 4b+2 and 4b+4 as noted in the definition of doubleBin.
{-
doubleBinBin' : (b : Bin) → doubleBin b ≡ doubleBin' b
doubleBinBin' b0     = refl
doubleBinBin' (s1 b) = {!!} -- Goal: s2 (doubleBin b) ≡ bsuc (bsuc (ℕ→Bin (doubleℕ (doubleℕ (Bin→ℕ b)))))
doubleBinBin' (s2 b) = {!!} -- Goal: s2 (s1 b)        ≡ bsuc (bsuc (bsuc (bsuc (ℕ→Bin (doubleℕ (doubleℕ (Bin→ℕ b)))))))
-}

----------------------

data Natty : Bin → Set where
  n0   : Natty b0
  nsuc : (b : Bin) → Natty b → Natty (bsuc b)

s1Natty : (b : Bin) → Natty b → Natty (s1 b)
s1Natty .b0       n0         = nsuc b0 n0
s1Natty .(bsuc b) (nsuc b n) = nsuc (s2 b) (nsuc (s1 b) (s1Natty b n))

s2Natty : (b : Bin) → Natty b → Natty (s2 b)
s2Natty .b0       n0         = nsuc (s1 b0) (nsuc b0 n0)
s2Natty .(bsuc b) (nsuc b n) = nsuc (s1 (bsuc b)) (nsuc (s2 b) (s2Natty b n))

natty : (b : Bin) → Natty b
natty b0     = n0
natty (s1 b) = s1Natty b (natty b)
natty (s2 b) = s2Natty b (natty b)

natPeano : (P : ℕ → Set) → P zero → ((n : ℕ) → P n → P (suc n)) → (n : ℕ) → P n
natPeano P p0 psuc zero    = p0
natPeano P p0 psuc (suc n) = psuc n (natPeano P p0 psuc n)

natPeanoId : ℕ → ℕ
natPeanoId = natPeano (λ _ → ℕ) zero (λ _ n → suc n)

natPeanoIdSuc : (n : ℕ) → natPeanoId (suc n) ≡ suc (natPeanoId n)
natPeanoIdSuc n = refl

natPeanoIdId : (n : ℕ) → natPeanoId n ≡ n
natPeanoIdId = natPeano (λ n → natPeanoId n ≡ n) refl (λ n ih → natPeanoIdSuc n ∙ cong suc ih)

-- Since (natPeanoIdSuc n) is just refl, the proof collapses as follows.
natPeanoIdId' : (n : ℕ) → natPeanoId n ≡ n
natPeanoIdId' = natPeano (λ n → natPeanoId n ≡ n) refl (λ n ih → cong suc ih)

nattyPeano : (P : Bin → Set) → P b0 → ((b : Bin) → P b → P (bsuc b)) → (b : Bin) → Natty b → P b
nattyPeano P p0 psuc .b0       n0         = p0
nattyPeano P p0 psuc .(bsuc b) (nsuc b n) = psuc b (nattyPeano P p0 psuc b n)

binPeano : (P : Bin → Set) → P b0 → ((b : Bin) → P b → P (bsuc b)) → (b : Bin) → P b
binPeano P p0 psuc b = nattyPeano P p0 psuc b (natty b)

binPeanoId : Bin → Bin
binPeanoId = binPeano (λ _ → Bin) b0 (λ _ b → bsuc b)

binPeanoIdSuc : (b : Bin) → binPeanoId (bsuc b) ≡ bsuc (binPeanoId b)
binPeanoIdSuc b = {!!}

-- Follows exactly the uncollapsed natPeanoIdId.
binPeanoIdId : (b : Bin) → binPeanoId b ≡ b
binPeanoIdId = binPeano (λ b → binPeanoId b ≡ b) refl (λ b ih → binPeanoIdSuc b ∙ cong bsuc ih)
